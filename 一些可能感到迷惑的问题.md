# 一些可能感到迷惑的问题



## 来源

主要来自《操作系统真相还原一书》，解答了我许多疑惑

### 01 操作系统是什么

操作系统是管理资源的软件，他为用户进程提供系统调用，当用户进程需要某个资源时，可直接调用，不需要考虑硬件的事情，因此用户进程可以专注自己的工作。

操作系统为保护计算机系统，不允许用户进程直接访问硬件资源，比如如果用户进程将操作系统所占据的内存恶意覆盖，那么操作系统也就不存在了。

此外，操作系统可以对内存进行管理等等，操作系统与用户进程之间的关系就好像是社会组织与人之间的关系



### 03 写操作系统需要人做的事情

操作系统能做什么，主要取决于主机上硬件的功能，软件的逻辑需要作用在硬件上才能体现出来，所以写操作系统需要了解硬件，硬件提供了软件方面的接口，我们需要知道如何通过计算机指令来操控硬件



### 04 软件如何访问硬件

IO接口是是各种硬件的适配设备，接口就是标准，生产出来的硬件按照这个标准工作就实现了通信

硬件的输入输出主要分为串行和并行，接口也有串行接口和并行接口，串行硬件通过串行接口与CPU进行通信，并行同理。

访问外部硬件的两种方式：

###### 1.将外设的内存映射到一定范围的地址空间中

CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器，CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端1MB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上 写字节便是往屏幕上打印内容

###### 2.外设通过IO接口与CPU通信

CPU访问外设，就是访问IO接口，由IO接口将信息传递 给另一端的外设，也就是说，CPU 从来不知道有这些设备的存在，它只知道自己操作的IO接口



### 05 应用程序和操作系统怎么配合到一起

应用程序和操作系统都是软件，CPU对两者并不加以区分，CPU只知道去cs:ip寄存器指向的内存存取指令并执行

应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译器。是编译器决定怎样解释某种关键字及某种语法 语言只是编译器和大家的约定，只要写入这样的代码， 编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关

编译器提供了一套库函数，库函数中有封装的系统调用，这种代码集合被称为运行库，C语言的运行库就是CRT

用户态与内核态是对 CPU 来讲的，是指CPU运行在用户态（特权3级）还是内核态（特权0级）

内核态（Kernel Mode）：运行操作系统程序，操作硬件

用户态（User Mode）：运行用户程序

#### 内核态与用户态的区别

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。**因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；**

- 当程序运行在0级特权级上时，就可以称之为运行在内核态。

- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 这两种状态的主要差别是

  > - 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
  > - 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的

#### 用户态切换到内核态的三种情况

系统调用  异常   外围设备中断

- 系统调用

**这是用户态进程主动要求切换到内核态的一种方式**，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**比如前例中fork()实际上就是执行了一个创建新进程的系统调用。

而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。

- 异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

- 外围设备的中断

**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号**，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，

如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。**

部分内容来自[用户态和内核态的区别 - Gizing - 博客园 (cnblogs.com)](https://www.cnblogs.com/gizing/p/10925286.html)

编译器是如何知道系统调用接口是什么，下载编译器时，要选择系统版本，编译器在设计时也要知道自己将来运行在哪个系统平台上，所以这都是和系统绑定好的，各个操作系统都有自己的系统调用号，编译器厂商在代码中已经把宿主系统的系统调用号写死



### 06 为什么称陷入内核

应用程序处于特权3级 ，操作系统内核处于特权0级 。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用。这样 CPU 便进入了内核态，也称管态。看图中凹下去的部分，有陷进去的感觉，这就是“陷入内核”

![](F:\计算机系统\陷入内核.PNG)

### 07 内存访问为什么分段

历史遗留问题

8086时期CPU和寄存器都是16位，且只有物理地址，访问存储单元直接给出物理地址

若加载程序运行，不管其是内核程序，还是用户程序，程序中的地址若都是绝对物理地址，那该程序必须放在内存中固定的地方，于是，两个编译出来地址相同的用户程序没法同时运行，只能运行一个。用分段的方式解决了这一问题，让 CPU 采用“段基址＋段内偏移地址”的方式来访问任意内存，这 样的好处是程序可以重定位了，尽管程序指令中给的是绝对物理地址，但终究可以同时运行多个程序了

重定位就是将程序中指令的地址改成另外一个地址，但该地址处的内容还是原地址处的内容

CPU 采用 “段基址＋段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器，这些是 cs，ds，es等。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移地址便可， CPU中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。

16 位的寄存器最多访问到 64阻大小的内存。虽然 lMB 内存中可容纳 lMB/64KB＝16 个最大段，但 这只是可以容纳而己，并不是说可以访问到。 16 位的寄存器超过 Oxffff 后将会回卷到0，又从0重新开始。 20 位宽度的内存地址空间必然只能由 20 位宽度的地址来访问。CPU 设计者在地址处理单元中动了手脚，该地址部件接到“段基址＋段内偏移地址”的地址后， 自动将段基址乘以 16 ，即左移了4位，然后再和 16 位的段内偏移地址相加，这下地址变成了 20 位



### 08 代码分为代码段和数据段

程序分段是为了让程序更加优美

x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访问的内存段起始地址。我们这里讨论的程序代码中的段（用 section或segment 来定义的段，不同汇编编译器提供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事，在硬件的内存访问机制中，处理器要用硬件一一段寄存器，指向软件一一程序代码中用 section或segment 以软件形式所定义的内存段 

分段是必然的，只是在**平坦模型下，硬件段寄存器中指向的内存段为最大的 4GB** ，而 多段模式下编程，硬件段寄存器中指向的内存段大小不一

一般的高级语言不允许程序员自己将代码分成各种各样的段，这是因为其所用的编译器是针对某个操作系统编写的，该操作系统采用的是**平坦模型**，所以该编译器要编译出适合此操作系统加载运行的程序。 由于处理器支持了具有分页机制的虚拟内存，操作系统也采用了分页模型，因此编译器会将程序按内容分成代码段和数据段，如编译器 gcc会把C语言写出的程序划分成代码段、数据段、栈段、.bss 段、堆等部分，这会由操作系统将编译器编译出来的用户程序中的各个段分配到不同的物理内存上。对于目前咱们用高级语言编码来说，我们之所以不用关心如何将程序分段，正是由于编译器按平坦模型编译，而程序依赖的操作系统又采用了虚拟内存管理，即处理器的分页机制。像汇编这种低级语言允许程序员为自己的程序分段，能够灵活地编排布局，这就属于人为将程序分成段了，也就是采用多段模型编程

#### 平坦内存模式

1.它的数据段和代码段是32位的，所以能访问4G的内存。 2.在“平坦内存模式”，cs、ds、es的值不需你操心，也不必知道它们的值是多少，它们的值是相等的

#### CPU指令执行

要给出 CPU 第一个指令的起始地址， CPU 在它执行本指令的同时，它会自动获取下一条的地址， 然后重复上述过程，继续执行，继续取址

程序**中的指令都是挨着的，彼此之间无空隙**，下一条指令的地址是按照前面指令的尺寸大小排下来的，这就是 Intel 处理器的程序计数器 **es: ip  能够自动获得下一条指令**的原理，即将当前 **eip 中的地址加上当前指令机器码的大小便是内存中下一条指令的起始地址**，即使指令间有空隙或其他非指令的数据，这也仅仅是在物理上将其断开了，依然可以用 jmp 指令将非指令部分跳过以保持指令在逻辑上连续

#### 数据与代码分开的好处

第一，可以为它们赋予不同的属性。 例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。

第二，为了提高 CPU 内部缓存的命中率。 大伙儿知道，缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。 CPU 内部有针对数据和针对指令的两种缓存机制，因此，将数据和代码分开存储将使程序运行得更快。 

第三，节省内存。 程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代码段共享就可以了。



### 09 物理地址、逻辑地址、有效地址、线性地址和虚拟地址的区别

物理地址就是物理内存真正的地址，不管在什么模式下，虚拟地址、线性地址， 最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。

在实模式下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址， CPU可以直接用此地址访问内存

而在保护模式下，＂段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址了，而是 个称为选择子的东西，它本质是个索引，类似于数组下标，通过这个索引便能在GDT中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能， 此线性地址就被 作物理地址来用，可直接访问内存若开启了分页功能，此线性地址又多了个名字，就是虚拟地址（虚拟地址、线性地址在分页机制下都是一回事） 虚拟地址要经过CPU页部件转换成具体的物理地 址，这样CPU才能将其送上地址总线去访问内存

无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可见的地址，这是因为，最终的地址是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的，要么是在实模式下的默认段寄存器中，要么是在保护模式下的默认段选择子寄存器指向的段描述符中，所以只要给出段内偏移地址就行了，这个地址虽然只是段内偏移，但加上默认的段基址，依然足够有效 

线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。由于分页功能是需要在保护模式下开启的，位系统保护模式下的寻址空间是4GB ，所以虚拟地址或线性地址就是4G的范围



### 12 cs ds等寄存器位宽是多少

CPU中存在段寄存器是因为其内存是分段访问的

CPU内部的段寄存器

(1).CS——代码段寄存器，其值为代码段的段基址

(2) DS一－数据段寄存器（ Data Segment Register ），其值为数据段的段基值。

(3) ES －附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，称为“附加”是 因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。

(4) FS一一附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定， 使用上灵活机动。

(5) GS一一附加段寄存器（ Ex Segment Register ），其值为附加数据段的段基值。

(6) SS 一一堆枝段寄存器（ Stack Segment Register ），其值为堆枝段的段值。

32位有两种工作模式：实模式和保护模式

在实模式下， cs DS ES SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子” ,  选择子也是数值，其依然为16位宽度。



### 14 linux系统下的应用程序不能在windows系统下运行

格式不同，格式就是在某个固定的位置有固定意义的数据，Linux的可执行程序格式是elf，有节、段信息、程序入口。window的可执行程序是PE格式

系统调用不同，Linux的API是通过int 0x80这个软中断实现，windows的系统调用放在DLL动态链接库中



### 15 局部变量和函数参数为什么要放在栈中

局部变量，顾名思义其作用域属于局部，并不是像 static 那样属于全局性的。全局的变量，意味着谁都可以随时随地访问，所以其放在数据段中，而局部变量只是自己在用，放在数据段中纯属琅费空间，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。栈由于是向下生长的，堆栈框架就是把 esp 指针提前加一个数，原 esp 指针到新 esp 指针之间的横空间用来存储局部变量。堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。

堆是堆，而堆栈就是栈，和堆没关系，只是都这么叫。栈和堆栈都是指的栈，在C语言的内存布局中，由于堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗

