# 一些可能感到迷惑的问题



## 来源

主要来自《操作系统真相还原一书》，解答了我许多疑惑

### 01 操作系统是什么

操作系统是管理资源的软件，他为用户进程提供系统调用，当用户进程需要某个资源时，可直接调用，不需要考虑硬件的事情，因此用户进程可以专注自己的工作。

操作系统为保护计算机系统，不允许用户进程直接访问硬件资源，比如如果用户进程将操作系统所占据的内存恶意覆盖，那么操作系统也就不存在了。

此外，操作系统可以对内存进行管理等等，操作系统与用户进程之间的关系就好像是社会组织与人之间的关系



### 03 写操作系统需要人做的事情

操作系统能做什么，主要取决于主机上硬件的功能，软件的逻辑需要作用在硬件上才能体现出来，所以写操作系统需要了解硬件，硬件提供了软件方面的接口，我们需要知道如何通过计算机指令来操控硬件



### 04 软件如何访问硬件

IO接口是是各种硬件的适配设备，接口就是标准，生产出来的硬件按照这个标准工作就实现了通信

硬件的输入输出主要分为串行和并行，接口也有串行接口和并行接口，串行硬件通过串行接口与CPU进行通信，并行同理。

访问外部硬件的两种方式：

###### 1.将外设的内存映射到一定范围的地址空间中

CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让 CPU 访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器，CPU 不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端1MB 的0xB8000～0xBFFFF。CPU 访问这片内存就是访问显存，住这片内存上 写字节便是往屏幕上打印内容

###### 2.外设通过IO接口与CPU通信

CPU访问外设，就是访问IO接口，由IO接口将信息传递 给另一端的外设，也就是说，CPU 从来不知道有这些设备的存在，它只知道自己操作的IO接口



### 05 应用程序和操作系统怎么配合到一起

应用程序和操作系统都是软件，CPU对两者并不加以区分，CPU只知道去cs:ip寄存器指向的内存存取指令并执行

应用程序要用某种语言编写，而语言又是编译器来提供的。其实根本就没有什么语言，有的只是编译器。是编译器决定怎样解释某种关键字及某种语法 语言只是编译器和大家的约定，只要写入这样的代码， 编译器便将其翻译成某种机器指令，翻译成什么样取决于编译器的行为，和语言无关

编译器提供了一套库函数，库函数中有封装的系统调用，这种代码集合被称为运行库，C语言的运行库就是CRT

用户态与内核态是对 CPU 来讲的，是指CPU运行在用户态（特权3级）还是内核态（特权0级）

内核态（Kernel Mode）：运行操作系统程序，操作硬件

用户态（User Mode）：运行用户程序

#### 内核态与用户态的区别

- 内核态与用户态是操作系统的两种运行级别，当程序运行在3级特权级上时，就可以称之为运行在用户态。**因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态；**

- 当程序运行在0级特权级上时，就可以称之为运行在内核态。

- 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。

- 这两种状态的主要差别是

  > - 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的
  > - 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的

#### 用户态切换到内核态的三种情况

系统调用  异常   外围设备中断

- 系统调用

**这是用户态进程主动要求切换到内核态的一种方式**，**用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。**比如前例中fork()实际上就是执行了一个创建新进程的系统调用。

而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

用户程序通常调用库函数，由库函数再调用系统调用，因此有的库函数会使用户程序进入内核态（只要库函数中某处调用了系统调用），有的则不会。

- 异常

当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

- 外围设备的中断

**当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号**，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，

如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

**这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。**

部分内容来自[用户态和内核态的区别 - Gizing - 博客园 (cnblogs.com)](https://www.cnblogs.com/gizing/p/10925286.html)

编译器是如何知道系统调用接口是什么，下载编译器时，要选择系统版本，编译器在设计时也要知道自己将来运行在哪个系统平台上，所以这都是和系统绑定好的，各个操作系统都有自己的系统调用号，编译器厂商在代码中已经把宿主系统的系统调用号写死



### 06 为什么称陷入内核

应用程序处于特权3级 ，操作系统内核处于特权0级 。当用户程序欲访问系统资源时（无论是硬件，还是内核数据结构），它需要进行系统调用。这样 CPU 便进入了内核态，也称管态。看图中凹下去的部分，有陷进去的感觉，这就是“陷入内核”

![](F:\计算机系统\陷入内核.PNG)

### 07 内存访问为什么分段

历史遗留问题

8086时期CPU和寄存器都是16位，且只有物理地址，访问存储单元直接给出物理地址

若加载程序运行，不管其是内核程序，还是用户程序，程序中的地址若都是绝对物理地址，那该程序必须放在内存中固定的地方，于是，两个编译出来地址相同的用户程序没法同时运行，只能运行一个。用分段的方式解决了这一问题，让 CPU 采用“段基址＋段内偏移地址”的方式来访问任意内存，这 样的好处是程序可以重定位了，尽管程序指令中给的是绝对物理地址，但终究可以同时运行多个程序了

重定位就是将程序中指令的地址改成另外一个地址，但该地址处的内容还是原地址处的内容

CPU 采用 “段基址＋段内偏移地址”的形式访问内存，就需要专门提供段基址寄存器，这些是 cs，ds，es等。程序中需要用到哪块内存，只要先加载合适的段到段基址寄存器中，再给出相对于该段基址的偏移地址便可， CPU中的地址单元会将这两个地址相加后的结果用于内存访问，送上地址总线。

16 位的寄存器最多访问到 64阻大小的内存。虽然 lMB 内存中可容纳 lMB/64KB＝16 个最大段，但 这只是可以容纳而己，并不是说可以访问到。 16 位的寄存器超过 Oxffff 后将会回卷到0，又从0重新开始。 20 位宽度的内存地址空间必然只能由 20 位宽度的地址来访问。CPU 设计者在地址处理单元中动了手脚，该地址部件接到“段基址＋段内偏移地址”的地址后， 自动将段基址乘以 16 ，即左移了4位，然后再和 16 位的段内偏移地址相加，这下地址变成了 20 位



### 08 代码分为代码段和数据段

程序分段是为了让程序更加优美

x86 平台的处理器是必须要用分段机制访问内存的，正因为如此，处理器才提供了段寄存器，用来指定待访问的内存段起始地址。我们这里讨论的程序代码中的段（用 section或segment 来定义的段，不同汇编编译器提供的关键字有所区别，功能是一样的）和内存访问机制中的段本质上是一回事，在硬件的内存访问机制中，处理器要用硬件一一段寄存器，指向软件一一程序代码中用 section或segment 以软件形式所定义的内存段 

分段是必然的，只是在**平坦模型下，硬件段寄存器中指向的内存段为最大的 4GB** ，而 多段模式下编程，硬件段寄存器中指向的内存段大小不一

一般的高级语言不允许程序员自己将代码分成各种各样的段，这是因为其所用的编译器是针对某个操作系统编写的，该操作系统采用的是**平坦模型**，所以该编译器要编译出适合此操作系统加载运行的程序。 由于处理器支持了具有分页机制的虚拟内存，操作系统也采用了分页模型，因此编译器会将程序按内容分成代码段和数据段，如编译器 gcc会把C语言写出的程序划分成代码段、数据段、栈段、.bss 段、堆等部分，这会由操作系统将编译器编译出来的用户程序中的各个段分配到不同的物理内存上。对于目前咱们用高级语言编码来说，我们之所以不用关心如何将程序分段，正是由于编译器按平坦模型编译，而程序依赖的操作系统又采用了虚拟内存管理，即处理器的分页机制。像汇编这种低级语言允许程序员为自己的程序分段，能够灵活地编排布局，这就属于人为将程序分成段了，也就是采用多段模型编程

#### 平坦内存模式

1.它的数据段和代码段是32位的，所以能访问4G的内存。 2.在“平坦内存模式”，cs、ds、es的值不需你操心，也不必知道它们的值是多少，它们的值是相等的

#### CPU指令执行

要给出 CPU 第一个指令的起始地址， CPU 在它执行本指令的同时，它会自动获取下一条的地址， 然后重复上述过程，继续执行，继续取址

程序**中的指令都是挨着的，彼此之间无空隙**，下一条指令的地址是按照前面指令的尺寸大小排下来的，这就是 Intel 处理器的程序计数器 **es: ip  能够自动获得下一条指令**的原理，即将当前 **eip 中的地址加上当前指令机器码的大小便是内存中下一条指令的起始地址**，即使指令间有空隙或其他非指令的数据，这也仅仅是在物理上将其断开了，依然可以用 jmp 指令将非指令部分跳过以保持指令在逻辑上连续

#### 数据与代码分开的好处

第一，可以为它们赋予不同的属性。 例如数据本身是需要修改的，所以数据就需要有可写的属性，不让数据段可写，那程序根本就无法执行啦。程序中的代码是不能被更改的，这样就要求代码段具备只读的属性。

第二，为了提高 CPU 内部缓存的命中率。 大伙儿知道，缓存起作用的原因是程序的局部性原理。在 CPU 内部也有缓存机制，将程序中的指令 和数据分离，这有利于增强程序的局部性。 CPU 内部有针对数据和针对指令的两种缓存机制，因此，将数据和代码分开存储将使程序运行得更快。 

第三，节省内存。 程序中存在一些只读的部分，比如代码，当一个程序的多个副本同时运行时（比如同时执行多个 ls 命令时），没必要在内存中同时存在多个相同的代码段，这将浪费有限的物理内存资源，只要把这一个代码段共享就可以了。



### 09 物理地址、逻辑地址、有效地址、线性地址和虚拟地址的区别

物理地址就是物理内存真正的地址，不管在什么模式下，虚拟地址、线性地址， 最终都要以物理地址去访问内存，只有物理地址才是内存访问的终点站。

在实模式下，“段基址＋段内偏移地址”经过段部件的处理，直接输出的就是物理地址， CPU可以直接用此地址访问内存

而在保护模式下，＂段基址＋段内偏移地址”称为线性地址，不过，此时的段基址已经不再是真正的地址了，而是 个称为选择子的东西，它本质是个索引，类似于数组下标，通过这个索引便能在GDT中找到相应的段描述符，在该描述符中记录了该段的起始、大小等信息，这样便得到了段基址。若没有开启地址分页功能， 此线性地址就被 作物理地址来用，可直接访问内存若开启了分页功能，此线性地址又多了个名字，就是虚拟地址（虚拟地址、线性地址在分页机制下都是一回事） 虚拟地址要经过CPU页部件转换成具体的物理地 址，这样CPU才能将其送上地址总线去访问内存

无论在实模式或是保护模式下，段内偏移地址又称为有效地址，也称为逻辑地址，这是程序员可见的地址，这是因为，最终的地址是由段基址和段内偏移地址组合而成的。由于段基址已经有默认的，要么是在实模式下的默认段寄存器中，要么是在保护模式下的默认段选择子寄存器指向的段描述符中，所以只要给出段内偏移地址就行了，这个地址虽然只是段内偏移，但加上默认的段基址，依然足够有效 

线性地址或称为虚拟地址，这都不是真实的内存地址。它们都用来描述程序或任务的地址空间。由于分页功能是需要在保护模式下开启的，位系统保护模式下的寻址空间是4GB ，所以虚拟地址或线性地址就是4G的范围



### 12 cs ds等寄存器位宽是多少

CPU中存在段寄存器是因为其内存是分段访问的

CPU内部的段寄存器

(1).CS——代码段寄存器，其值为代码段的段基址

(2) DS一－数据段寄存器（ Data Segment Register ），其值为数据段的段基值。

(3) ES －附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，称为“附加”是 因为此段寄存器用途不像其他 sreg 那样固定，可以额外做他用。

(4) FS一一附加段寄存器（ Extra Segment Register ），其值为附加数据段的段基值，同上，用途不固定， 使用上灵活机动。

(5) GS一一附加段寄存器（ Ex Segment Register ），其值为附加数据段的段基值。

(6) SS 一一堆枝段寄存器（ Stack Segment Register ），其值为堆枝段的段值。

32位有两种工作模式：实模式和保护模式

在实模式下， cs DS ES SS 中的值为段基址，是具体的物理地址，内存单元的逻辑地址仍为 “段基值：段内偏移量”的形式。在保护模式下，装入段寄存器的不再是段地址，而是“段选择子” ,  选择子也是数值，其依然为16位宽度。



### 14 linux系统下的应用程序不能在windows系统下运行

格式不同，格式就是在某个固定的位置有固定意义的数据，Linux的可执行程序格式是elf，有节、段信息、程序入口。window的可执行程序是PE格式

系统调用不同，Linux的API是通过int 0x80这个软中断实现，windows的系统调用放在DLL动态链接库中



### 15 局部变量和函数参数为什么要放在栈中

局部变量，顾名思义其作用域属于局部，并不是像 static 那样属于全局性的。全局的变量，意味着谁都可以随时随地访问，所以其放在数据段中，而局部变量只是自己在用，放在数据段中纯属琅费空间，故将其放在自己的栈中，随时可以清理，真正体现了局部的意义。栈由于是向下生长的，堆栈框架就是把 esp 指针提前加一个数，原 esp 指针到新 esp 指针之间的横空间用来存储局部变量。堆是程序运行过程中用于动态内存分配的内存空间，是操作系统为每个用户进程规划的，属于软件范畴。栈是处理器运行必备的内存空间，是硬件必需的，但又是由软件（操作系统）提供的。

堆是堆，而堆栈就是栈，和堆没关系，只是都这么叫。栈和堆栈都是指的栈，在C语言的内存布局中，由于堆和栈的地址空间是接壤的，栈从高地址往低地址发展，堆是从低地址往高地址发展，堆和栈早晚会碰头，它们各自的大小取决于实际的使用情况，界限并不明朗

函数参数为什么放在栈区，一是因为其局部性导致的，只有这个函数用这个参数，何必将其放在数据段呢 ，二是因为函数是在程序执行过程中调用的，属于动态的调用，编译时无法预测会何时调用及被调用的次数，函数的参数及返回值都需要内存来存储，如果是递归调用的话，参数及返回值需要的内存空间不确定，这取决于递归的次数



### 18 编译型程序与解释型程序的区别

解释型语言或者脚本语言，本身是文本文件，是某个应用程序的输入，应用程序就算脚本解释器。

脚本中的代码不用真正上CPU去执行，CPU的cs:ip寄存器从来没有指向过他们。本质上是脚本解释器在实时分析脚本，动态根据关键字和语法做出相应的行为，因此脚本中出现错误，先前正确的部分也会被执行



### 19 什么是大端字节序、小端字节学

(1）小端字节序是数值的低字节放在内存的低地址处，数值的高字节放在内存的高地址。

(2）大端字节序是数值的低字节放在内存的高地址处，数值的高字节放在内存的低地址。

#### 两种字节的优势

小端：因为低位在低字节，强制转换数据型时不需要再调整字节了。 

大端：有符号数，其字节最高位不仅表示数值本身，还起到了符号的作用。符号位固定为第一字节，也就是最高位占据最低地址，符号直接可以取出来，容易判断正负

常见的大端字节序有IBM。。。小端字节序：x86         ARM是大小端通吃，由硬件来进行选择

网络字节序是大端字节序，所以在x86架构上的程序发送网络数据时，要转换字节序



### 20 BIOS中断、DOS中断、Linux中断的区别

BIOS和DOS都是存在于实模式下的程序，由它们建立的中断调用建立在中断向量表中，通过软中断指令int中断号来实现

中断向量表中的每个中断向量大小是4字节，描述了一个中断处理例程的段基址和段内偏移地址。中断向量表长度是1024字节，故最多容纳256个中断向量处理程序，计算机启动之初，中断向量表中的中断例程由BIOS建立，从物理内存地址0x0000处初始化并在中断向量表中添加各种例程

BIOS中断主要功能是提供了硬件访问的方法

BIOS添加中断处理例程一是为了给自己使用，二是给后来的程序，如加载器或boot loader使用

#### 硬件的接口代码

每个外设，都有自己的内存，这种内存是只读存储器ROM，硬件的功能调用例程以及初始化代码存放在此

根据规范，第1个内存单元的内容是 Ox55 ，第2个存储单元是 OxAA，第3个存储单位是该 rom 中以 512 字节为单位的代码长度。从第4个存储单元起就是实际代码了，直到第3个存储单元所示的长度为止。

CPU访问外设：内存映射   端口操作

中断向量表中第0H~ 1FH 项是 BIOS 中断    0x20~0x27是DOS中断，因为DOS在实模式下运行，所以可以调用BIOS中断

Linux 内核是在进入保护模式后才建立中断例程的，在保护模式下，中断向量表己经不存在了， 取而代之的是中断描述符表IDT

Linux 的系统调用和 DOS 中断调用类似，linux 是通过 int 0x80 指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数的



### 21 section 和segment的区别

C程序大体上分为预处理、编译、汇编和链接4个阶段。预处理阶段是预处理器将高级语言中的宏展开，去掉代码注释，为调试器添加行号等。编译阶段是将预处理后的高级语言进行词法分析、语法分析、语义分析、优化，最后生成汇编代码。汇编阶段是将汇编代码编译成目标文件，也就是转换成了目标机器 平台上的机器指令。链接阶段是将目标文件连接成可执行文件。

section 称为节，是指在汇编源码中经由关键字 section或segment 修饰、逻辑划分的指令或数据区域， 汇编器会将这两个关键字修饰的区域在目标文件中编译成节，也就是说“节”最初诞生于目标文件中 

segment称为段，是链接器根据目标文件中属性相同的多个section合并后的section集合，这个集合称为 segment，也就是段，链接器把目标文件链接成可执行文件，因此段最终诞生于可执行文件中。平时所说的可执行程序内存空间中的代码段和数据段就是指的 segment



### 23 操作系统如何识别文件系统

一个硬盘上可以有很多分区，每个分区的格式又可以不同。各分区都有超级块，一般位于本分区的第2个扇区，比如若各分区的扇区以0开始索引，其第1个扇区便是超级块的起始扇区.超级块里面记录了此分区的信息，其中就有文件系统的魔数， 一种文件系统对应一个魔数， 比对此值便知道文件系统类型了



### 25 指令集、体系结构、微架构、编程语言

最早的指令集是 CISC，意为复杂指令集计算机。后来出现了相对精简高效的指令集，称为 RISC

常用的CPU中Intel和AMD公司的产品，它们用的指令集便是基于CISC思想的x86。AMD的x86指令架构是Intel授权给他们的，为区别于此，Intel在官方手册上称自己的指令集为IA32

指令集是一套约定，里面规定的是有哪些指令、指令的二进制编码、指令格式等，如何实现这套约定，这是硬件自己的事。在Intel的CPU上运行的软件也能够在AMD的CPU上运行，原因就是它们共用了同一套指令集，也就是对二进制编码达成了共识。

它们面对相同的需求，可能采取了不同的行动，但都完成了任务。比如机器码是b80000, Intel的CPU经过译码，知道这是将0赋值给寄存器ax，相当于汇编语言 mov ax，0。 AMD的CPU在译码时，也得将此机器码认为是将0赋值给寄存器ax。至于它们在物理上是怎么将0传入寄存器ax中的，这是它们各自实现的方式，与指令集无关。它们各自实现的方式，就叫微架构。

指令集是具体的一套指令编码，微架构是指令集的物理实现方式。

x86是CISC指令体系，ARM是RISC指令体系



### 26 库函数是用户进程与内核的桥梁

(1）操作系统有自己支持、加载用户进程的规则，而C运行时库是针对此操作系统的规则，为了让用户程序开发更加容易，用来支持用户进程的代码库。大家要明白，之所以我们写个程序又链接这又链接 那的，完全是因为操作系统规定这样做，人在屋檐下，不得不低头。 

(2）用户进程要与C运行库的诸多目标文件链接后合并成一个可执行文件，也就是说我们的用户进程被加进了大量的运行库中的代码。

(3) 运行时库作用如其名，是提供程序运行时所需要的库文件，而且还做了程序运行前的初始化工作，所以即使不包含标准库文件，链接阶段也要用到C运行时库。 

(4）用户程序可以不和操作系统打交道，但如果需要操作系统的支持，必须要通过系统调用，它是用 户进程和操作系统之间的“钩子”，用户进程顶多算是个半成品，只有通过钩子挂上了操作系统，加了上所需要的操作系统的那部分代码，用户程序才能做完一件事，才算完整

(5）尽管系统调用封装在库函数中，但用户程序可以直接调用“系统调用”，不过用库函数会比较高效



### 28 MBR.EBR DBR和OBR各是什么

计算机在接电之后运行的是基本输入输出系统 BIOS，采用接力式控制权交接， BIOS 只完成一些简单的检或初始化工作，然后把处理器的使用权交给MBR，因此MBR位于整个硬盘最开始的扇区。

MBR 引导扇区中的内容是：

(1) 446 字节的引导程序及参数： 

(2) 64 字节的分区表： 

(3) 2字节结束标记 0x55和0xaa。

MBR 称为“主”引导程序。MBR 引导扇区中除了引导程序外，还有 64 字节大小的分区表，里面是分区信息。分区表中每个分区表项占 16 字节，因此 MBR 分区表中可容纳4个分区，这4个分区就是“次引导程序”的候选人群， MBR引导程序开始遍历这4个分区

为了MBR 方便找到活动分区上的内核加载器，内核加载器的入口地址也必须在固定的位置，这个位置就是各分区最开始的扇区，这也是约定好的。这个“各分区起始的扇区”中存放的是操作系统引导程序一一内核加载器，因此该扇区称为操作系统引导扇区，其中的引导程序（内核加载器〉称为操作系统引导记录OBR，即 OS Boot Record时，此扇区也称为 OBR 引导扇区。在 OBR 扇区的前3个字节存放了跳转指令，这同样是约定，因此 MBR 找到活动分区后，就大胆主动跳到活动分区 OBR 引导扇区的起始处，该起始处的跳 转指令马上将处理器带入操作系统引导程序，从此 MBR 完成于交接工作

DBR 是DOS Boot Record ，也就是 DOS 操作系统的引导记录（程序）

为了解决分区数量限制的问题才有了扩展分区， EBR 是扩展分区中为了兼容 MBR 才提出的概念，主要是兼容 MBR 中的分区表。

DBR OBR MBR EBR 都包含引导程序，因此它们都称为引导扇区，只要该扇区中存在可执行的程序，该扇区就是可引导扇区。若该扇区位于整个硬盘最开始的扇区，并且以0x55和0xaa结束，BIOS 就认为该扇区中存在 MBR，该扇区就是 MBR 引导扇区。若该扇区位于各分区最开始的扇区，井且以0x55和0xaa结束， MBR就认为该扇区中有操作系统引导程序 OBR，该扇区就是 OBR 引导扇区。

